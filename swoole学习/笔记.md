[toc]

## 1 swoole协程的发展

1 swoole1.x的时候，提供redis异步回调方法，但容易陷入回调陷阱。

```
$redisClient = new swoole_redis;
$redisClient->connect('127.0.0.1',6379,function(swoole_redis $redisClient,$result)) {
	$redisClient->set('asa', time(),function(swoole_redis $redisClient,$result)	{
		var_dump($result);
	})
}
```

2 swoole2.X时代，提供协程客户端，可以以同步的方法去写，但是需要作用在http服务器的onrequest等

```
$http = new swoole_http_server('0.0.0.0',8001);
$http->on('request',function($request,$response) {
	$redis = new Swoole\Coroutine\Redis();
	$redis->connect('127.0.0.1',6379);
	$value = $redis->get($request->get['a']);
	$response->end($value);
	//如果这里写mysql的协程客户端，这个请求的io时间将会是（max（mysql+redis））的时间
})
$http->start();
```

3 swoole4.X时代,提供了go关键字,co::sleep(1)是在协程内调用停止1秒，他最终输出的是"b主进程输出a"；如注释他打开下面的原生的sleep，他将会在睡眠1秒后，输出"a主进程调用b".

```
go(	function() {
    co::sleep(1);//是在这个协程内睡眠1秒
	//sleep(1);//执行全局停止
	echo 'a';
});
echo '主进程执行';
go(	function() {
	echo 'b';
});
```

4 swoole4.x时代，如协程tcp客户端，必须放在go关键字内，同时也可以放在onrequest事件回调内

5 对于协程mysql客户端，redis客户端推荐用一键携程的方法，swoole\Runtime::enableCoroutine(true)后面，mysql，redis就可以用原生的客户端去连，但要包在go里头。（如果没有swoole\Runtime::enableCoroutine(true)这一行，那么原生的mysql，redis将会是堵塞的，也能执行；开启了enableCoroutine(true)后，原生的redis客户端将会变为非堵塞的，当执行到她之后，将会让出协程调度权给另外一个协程）

## 2 Swoole\Runtime::enableCoroutine(true);一键携程客户端(如sleep，redis连接，读取等代码),4.4+用Co::set(['hook_flags'=> SWOOLE_HOOK_ALL]); 

携程是写在go里面，如redis是堵塞io，当遇到他时候，该携程会交出携程调度权，给其他携程（其他有go关键字包围的块）调用

go(function（） {
	echo file_put_contents('aa.txt','aa',FILE_APPEND);
})