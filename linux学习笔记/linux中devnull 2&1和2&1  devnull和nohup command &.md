[toc]

## 基础

1> ： 代表标准正确输出，即如果命令的执行结果是正确，则执行输出，一般来说, "1>" 通常可以省略成 ">". 

2> ： 代表标准错误输出，即如果命令的执行结果是错误，则执行输出

&>： 代表标准正确输出+标准错误输出, &>filename 意思是把标准输出和标准错误输出都重定向到文件filename中



## 高级用法

### 重定向绑定

好了，在有了以上知识的基础上，我们再来看开头提到的`>/dev/null 2>&1`。这条命令其实分为两命令，一个是`>/dev/null`，另一个是`2>&1`。

#### 1. >/dev/null

这条命令的作用是将标准输出1重定向到/dev/null中。/dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了`>/dev/null`之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

#### 2. 2>&1

这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以`>/dev/null 2>&1`的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，**该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中**。

#### 3 .>/dev/null 2>&1 VS 2>&1 >/dev/null

再回到文章的开头，我说我弄反了`>/dev/null`和`2>&1`拼装的顺序，导致出了一点小问题。乍眼看这两条命令貌似是等同的，但其实大为不同。刚才提到了，linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析`2>&1 >/dev/null`：

1. 2>&1，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。
2. \>/dev/null，将标准输出1重定向到/dev/null中。

我们用一个表格来更好地说明这两条命令的区别：

| 命令            | 标准输出 | 错误输出 |
| --------------- | -------- | -------- |
| >/dev/null 2>&1 | 丢弃     | 丢弃     |
| 2>&1 >/dev/null | 丢弃     | 屏幕     |

#### 4. >/dev/null 2>&1 VS >/dev/null 2>/dev/null

那么可能会有些同学会疑问，为什么要用重定向绑定，而不是像`>/dev/null 2>/dev/null`这样子重复一遍呢。

为了回答这个问题，我们回到刚才介绍输出重定向的场景。我们尝试将标准输出和错误输出都定向到out文件中：

```
# ls a.txt b.txt >out 2>out
# cat out
a.txt�法访问b.txt: 没有那个文件或目录
```

WTF？竟然出现了乱码，这是为啥呢？这是因为采用这种写法，标准输出和错误输出会抢占往out文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况。现在是出现了乱码，有时候也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。

而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如`>/dev/null 2>&1`来得高。

### nohup结合

我们经常使用`nohup command &`命令形式来启动一些后台程序，比如一些java服务：

```
nohup java -jar xxxx.jar >/dev/null 2>&1 &
```