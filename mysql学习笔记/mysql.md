[toc]

## 1 B和B+树的区别

|                                | B树                    | B+                                             | 优势                                               |
| ------------------------------ | ---------------------- | ---------------------------------------------- | -------------------------------------------------- |
| 叶子节点                       | 把内容和索引都放在一起 | 只把内容放到了最后一层节点上，上面都是只存索引 | 存索引的空间更大，意味着更大的存储效率和查询效率。 |
| 最下一层叶子节点间有无指针相连 | 无                     | 有                                             | 范围查询更快速，无需往上再次查询                   |

 ## 2 3层B+树计算存储多少行？（假设每页是16k）

### 1 先算1行占多少？

4个int字段，占4 X 4 = 16字节

1 个varchar（20）字段 占 4n+2=4X20+2 =82

所以一行先算他100个字节。

### 2 算出单个叶子节点所存储的行数

16000 / 100 = 160条记录

### 3 根据非叶子节点的情况，算出总共多少个叶子节点

根节点:  
他存索引，索引假设是一个int字段，存放4个字节

另外，指向下一个索引的指针，只会占6个字节。

单个非叶子节点，总共可以存 16000/4+6 = 1600个指针



2层节点：
是存1600的平方 大约2560000个指针（等同有多少个叶子节点）

### 4 最后算出总数

2560000（总共叶子节点数） X 160（每个叶子节点的所能存储的行数） =  4096 00000

### 3 索引

### 1 唯一索引

查找性能 查找到第一个满足条件的记录，就不再查找。

更新性能 找到2和6的之间的位置，

## 3 mysql mvcc和锁的说明

### 1 读有两种方式（快照读和当前读）

快照读 就是普通的select 语句

当前读 就是select for update，select lock in share mode ，update，delete，insert

### 2 在RC隔离级别下（解决了脏读）

#### 1 快照读（mvcc）

因为每一次读都会产生一个readview，所以不可重复读

#### 2 当前读

当前读（如 `SELECT ... FOR UPDATE`）会对读取到的行加 **行锁**（Record Lock）。由于 RC 级别 **没有间隙锁（Gap Lock）**，所以仍可能出现 **幻读**。（其实是可以重复读的，但由于缺少间隙锁，所以仍然可能出现幻读）

### 3 在RR隔离级别下（解决了不可重复读）

#### 1 快照读（mvcc）

在事务期间，多次快照读只会沿用第一次快照读的版本

#### 2 当前读

当前读会对满足条件的记录加 2种锁，间歇锁解决幻读问题，行锁解决不可重复读的问题，
间歇锁只在where条件上锁

#### 3 完全解决了幻读？

同一个事务中混合使用快照读和当前读的情况下，快照读不设锁...因此，在同一个事务中，快照读和加锁读可能会看到不同的数据（deepseek），所以没法完全解决幻读
