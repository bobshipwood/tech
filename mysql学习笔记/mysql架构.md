[toc]

## 1 mysql 3层架构

### 1 Client Connectors层

负责处理客户端的请求，与客户端创建连接。例如常见的jdbc，go等

### 2 server 层

#### 1 Conection Pool

一个线程负责管理一个连接。包含了用户验证模块等

#### 2 Service & utilities 

包括备份恢复，安全管理，集群管理和工具

#### 3 SQL interface

负责接收客户端发来的各种sql语句，比如DML，DDL和存储过程等。

#### 4 解析器

Praser解析器会对各sql语句进行语法分析生成解析树

#### 5 优化器

Optimizer 查询优化器会根据解析数生成执行计划，并选择合适的索引

#### 6 Caches

包括各个存储引擎的缓存部分，如innodb的buffer pool myisam的key buffer等。，此外cache中也会缓存一些权限，包括一些session级别的缓存。

### 3 存储引擎层

包括myisam，innodb及支持归档的archive，和内存的memory等。

## 2 WAL（ARIES三原则）（Write Ahead Logging）(原子性保证的关键)

### 1 先写日志后写磁盘，日志成功写入事务后就不会丢失，后续由checkpoint机制来保证磁盘物理文件与Redo日志达到一致性；

### 2 用Redo记录变更后的数据，既Redo记录事务数据变更后的值；

### 3 用Undo记录变更前的数据，既Undo记录事务变更前的值，用于回滚和其他事务多版本读。

## 3 4种隔离级别与脏读，不可重复读，幻读的关系

### 1 脏读

一个事务正对一条记录进行修改，这个事务未提交前，这条记录的数据就处于不一致的状态；
如果另一个事务也来读取同一条记录，如果不加控制，则第2个事务读取了“脏”数据。并据此进行进一步的处理，就会产生未提交的数据依赖关系。这种现象称之为“脏读”

### 2 不可重复读（针对update ，delete）

当一个事务再次读取以前读过的数据，却发现数据已经发生了改变，或者删除了，这种现象叫作“不可重复读”

### 3 幻读（针对insert）

一个事务按相同条件重新读取以前读的记录，却发现其他事务插入了新的数据，。这种现象叫“幻读”

### 4 与隔离级别的关系

| 隔离级别                     | 脏读   | 不可重复读 | 幻读                                                         | 自我备注                                                     |
| ---------------------------- | ------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 未提交读（Read uncommitted） | 可能   | 可能       | 可能                                                         | 基本不会用到                                                 |
| 已提交读（Read commited）    | 不可能 | 可能       | 可能                                                         |                                                              |
| 可重复读（Repeatable Read）  | 不可能 | 不可能     | 可能（通过间歇锁（GAP）解决，update前加锁，拒绝其他事务insert） | 默认级别。但经常发生死锁，低并发等问题                       |
| 可串行化（Serializable）     | 不可能 | 不可能     | 不可能                                                       | 已经不是多版本（mvcc）了，又回到了单版本的状态，因为他所有实现都是通过锁 |
## 4 并发事务控制

### 1 单版本控制（锁）

### 2 多版本控制（MVCC）（只针对RC和RR）

### 3 一般建议

在RR（repeatable read）的模式下，为了解决幻读问题，会使用间隙性GAP锁，而这种锁由于并行度不够，冲突很多，经常引起死锁。
现在流形的ROW模式可以很大程度避免此类问题，所以一般采用 ROW+RC模式

## 5 mysql锁分类

### 1 三种锁分类

| 锁分类 | 开销     | 加锁速度 | 死锁可能性 | 锁冲突概率 | 并发度 | 存储引擎                    |
| ------ | -------- | -------- | ---------- | ---------- | ------ | --------------------------- |
| 表级锁 | 小       | 快       | 无         | 大         | 低     | myisam，innodb，memory，BDB |
| 行级锁 | 大       | 慢       | 会出现死锁 | 最低       | 最高   | innodb                      |
| 页级锁 | 两者之间 |          | 会         |            | 一般   | BDB                         |

### 2 innodb 5种锁

#### 1 共享锁（s）（行锁）

#### 2 排他锁（X）（行锁）

#### 3 意向共享锁（Is）（表锁）

#### 4 意向排他锁（IX）（表锁）

#### 5 自增锁（AUTO-INC Locks）（表锁）

特殊表锁，自增长计数器通过该锁来获得计数值

#### 6 加行锁前，必须获得表锁，否则等待innodb_lock_wait_timeout,超时后根据innodb_rockback_on_time_out来决定是否回滚事务

#### 7 死锁不会发生在myisam引擎中

### 3 innodb锁关系矩阵(Y兼容 N 不兼容)



#### 1 具体的sql语句

```csharp
select id from t where id = 1 for update;  # 获取id=1数据行的排它锁

select id from t where id =1 lock in share mode;  # 获取id=1数据行上的共享锁
    
select lock in share mode; #可以获得IS锁

select ... for update;  # 获得IX锁
```

#### 2 关系

| 下列表示如果事务获得的锁，右列表示另一个事务 | is   | ix   | auto-inc | s    | x    |
| -------------------------------------------- | ---- | ---- | -------- | ---- | ---- |
| is                                           | Y    | Y    | Y        | Y    | N    |
| ix                                           | Y    | Y    | Y        | N    | N    |
| auto-inc                                     | Y    | Y    | N        | N    | N    |
| s                                            | Y    | N    | N        | Y    | N    |
| x                                            | N    | N    | N        | N    | N    |

